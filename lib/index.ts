import { generatorHandler } from '@prisma/generator-helper';
import { SemicolonPreference } from 'typescript';
import {
  IndentationText,
  Project,
  QuoteKind,
  VariableDeclarationKind,
  type CodeBlockWriter,
} from 'ts-morph';

// @ts-expect-error - typescript doesn't like importing json, tell it to be quiet
import { version } from '../package.json';

generatorHandler({
  onManifest () {
    return {
      prettyName: 'Joi Schemas',
      defaultOutput: 'joi',
      version: version as string,
    };
  },
  async onGenerate (options) {
    const project = new Project({
      manipulationSettings: {
        quoteKind: QuoteKind.Single,
        useTrailingCommas: true,
        indentationText: IndentationText.TwoSpaces,
      },
    });

    const formatSettings = {
      indentSize: 2,
      semicolons: SemicolonPreference.Insert,
    };

    const models = options.dmmf.datamodel.models;
    const outputPath = options.generator.output?.value ?? './schema.ts';

    let indexFilePath = outputPath;
    if (!indexFilePath.endsWith('.ts')) {
      indexFilePath += '.ts';
    }
    const indexFile = project.createSourceFile(indexFilePath, {}, { overwrite: true });

    indexFile.insertText(0, '// This file is automatically generated. Changes will be overwritten the next time the Prisma generator is run.');

    indexFile.addImportDeclaration({
      moduleSpecifier: 'joi',
      defaultImport: 'Joi',
    });

    indexFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: false,
      leadingTrivia: (writer) => writer.blankLineIfLastNot(),
      declarations: [{
        name: 'Root',
        initializer: (writer) => {
          return writer
            .write('Joi.object().keys(')
            .inlineBlock(() => {
              for (const model of models) {
                writer
                  .write(`${model.name}: Joi.object().keys(`)
                  .inlineBlock(() => {
                    for (const field of model.fields) {
                      if (field.kind !== 'scalar' && field.kind !== 'object') {
                        continue;
                      }

                      writer.write(`${field.name}: `);

                      if (field.kind === 'scalar') {
                        if (field.type === 'String') {
                          writer.write('Joi.string()');
                        } else if (['Int', 'Float', 'Decimal'].includes(field.type)) {
                          writer.write('Joi.number()');
                          if (field.type === 'Int') {
                            writer.write('.integer()');
                          }
                        } else if (field.type === 'DateTime') {
                          writer.write('Joi.date()');
                        } else if (field.type === 'Boolean') {
                          writer.write('Joi.boolean()');
                        }

                        if (field.isId) {
                          const modelName = model.name[0].toLowerCase() + model.name.slice(1);
                          writer
                            .write('.alter(')
                            .inlineBlock(() => {
                              return writer
                                .write('create: (schema) => schema.forbidden(),')
                                .newLine()
                                .write(`update: (schema) => schema.valid(Joi.ref('$params.${modelName}Id')).strip(),`);
                            })
                            .write(')');
                        } else if (field.name === 'createdAt' || field.name === 'updatedAt' || field.name === 'deletedAt') {
                          writer
                            .write('.alter(')
                            .inlineBlock(() => {
                              return writer
                                .write('create: (schema) => schema.strip(),')
                                .newLine()
                                .write('update: (schema) => schema.strip(),');
                            })
                            .write(')');
                        } else if (field.isRequired) {
                          writer
                            .write('.alter(')
                            .inlineBlock(() => {
                              return writer
                                .write('create: (schema) => schema.required(),');
                            })
                            .write(')');
                        }

                        if (field.documentation) {
                          const joiMods = field.documentation
                            .split('\n')
                            .filter((line) => line.startsWith('@joi'))
                            .map((line) => line.slice(4).trim());

                          for (const mod of joiMods) {
                            writer.newLine().indent().write(mod);
                          }
                        }
                      } else {
                        if (field.isList) {
                          writer.write(`Joi.array().items(Joi.link('/${field.type}'))`);
                        } else {
                          writer.write(`Joi.link('/${field.type}')`);
                        }
                      }
                      writer.write(',').newLine();
                    }
                  })
                  .write('),')
                  .newLine();
              }
            })
            .write(')');
        },
      }],
    });

    indexFile.addStatements((writer) => writer.newLine().newLine());
  
    for (const model of models) {
      indexFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        isExported: true,
        leadingTrivia: (writer: CodeBlockWriter) => writer.blankLineIfLastNot(),
        declarations: [{
          name: model.name,
          initializer: (writer: CodeBlockWriter) => {
            return writer.write(`Root.extract('${model.name}')`);
          },
        }],
      });

      indexFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        isExported: true,
        declarations: [{
          name: `Create${model.name}`,
          initializer: (writer) => {
            return writer
              .write(`${model.name}.tailor('create')`);
          },
        }],
      });

      indexFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        isExported: true,
        declarations: [{
          name: `Update${model.name}`,
          initializer: (writer) => {
            return writer
              .write(`${model.name}.tailor('update')`);
          },
        }],
      });
    }

    indexFile.formatText(formatSettings);

    return await project.save();
  },
});
